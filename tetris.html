<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Canvas Tetris (JS)</title>
  <style>
    :root{--bg:#0b1220;--panel:#0f1724;--accent:#38bdf8;--muted:#94a3b8}
    *{box-sizing:border-box}
    body{font-family:system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif; margin:0; min-height:100vh; display:flex; align-items:center; justify-content:center; background:linear-gradient(180deg,#071126 0%, #071429 100%); color:#e6eef6}
    .wrap{display:flex; gap:20px; align-items:flex-start}
    canvas{background:linear-gradient(180deg,#07102a, #081427); image-rendering:pixelated; border-radius:8px; box-shadow:0 8px 24px rgba(2,6,23,0.7)}
    .panel{width:260px; background:var(--panel); border-radius:8px; padding:16px; box-shadow:0 6px 18px rgba(2,6,23,0.6)}
    h1{margin:0 0 12px 0; font-size:18px}
    .info{display:flex; gap:12px; margin-bottom:12px}
    .box{background:rgba(255,255,255,0.03); padding:10px; border-radius:6px; text-align:center}
    .muted{color:var(--muted); font-size:13px}
    button{width:100%; padding:10px; font-weight:600; border-radius:6px; border:none; cursor:pointer; margin-top:8px}
    button:hover{opacity:0.95}
    .btn-primary{background:var(--accent); color:#04263b}
    .controls{font-size:13px; color:#cfeeff}
    .small{font-size:12px; color:var(--muted)}
    footer{margin-top:10px; font-size:12px; color:var(--muted)}
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="tetris" width="300" height="600"></canvas>
    <div class="panel">
      <h1>Canvas Tetris (JS)</h1>
      <div class="info">
        <div class="box" style="flex:1">
          <div class="small">スコア</div>
          <div id="score">0</div>
        </div>
        <div class="box" style="width:84px">
          <div class="small">レベル</div>
          <div id="level">1</div>
        </div>
      </div>
      <div class="box" style="margin-bottom:10px">
        <div class="small">次のピース</div>
        <canvas id="next" width="120" height="120" style="background:rgba(255,255,255,0.02); border-radius:6px"></canvas>
      </div>
      <div class="controls">
        <div>操作:</div>
        <div>← → : 左右移動</div>
        <div>↓ : ソフトドロップ</div>
        <div>↑ : 回転</div>
        <div>Space : ハードドロップ</div>
        <div>P : 一時停止</div>
      </div>
      <button id="start" class="btn-primary">開始 / リスタート</button>
      <button id="pause">一時停止</button>
      <footer>作成: ChatGPT • Canvas + Vanilla JS</footer>
    </div>
  </div>

<script>
// --- 基本設定 ---
const canvas = document.getElementById('tetris');
const ctx = canvas.getContext('2d');
const nextCanvas = document.getElementById('next');
const nextCtx = nextCanvas.getContext('2d');
const COLS = 10, ROWS = 20;
const BLOCK = Math.floor(canvas.width / COLS); // ブロックサイズ
canvas.width = BLOCK * COLS;
canvas.height = BLOCK * ROWS;

// 色 (7個)
const COLORS = [null, '#60a5fa', '#f97316', '#34d399', '#f43f5e', '#a78bfa', '#facc15', '#fb7185'];

// テトロミノ定義 (4x4 回転行列として扱う)
const TETROMINOES = {
  I: [
    [0,0,0,0,
     1,1,1,1,
     0,0,0,0,
     0,0,0,0],
    [0,0,1,0,
     0,0,1,0,
     0,0,1,0,
     0,0,1,0]
  ],
  J: [
    [2,0,0,0,
     2,2,2,0,
     0,0,0,0,
     0,0,0,0],
  ],
  L: [
    [0,0,3,0,
     3,3,3,0,
     0,0,0,0,
     0,0,0,0]
  ],
  O: [
    [0,4,4,0,
     0,4,4,0,
     0,0,0,0,
     0,0,0,0]
  ],
  S: [
    [0,5,5,0,
     5,5,0,0,
     0,0,0,0,
     0,0,0,0]
  ],
  T: [
    [0,6,0,0,
     6,6,6,0,
     0,0,0,0,
     0,0,0,0]
  ],
  Z: [
    [7,7,0,0,
     0,7,7,0,
     0,0,0,0,
     0,0,0,0]
  ]
};

// すべてのテトロミノ名の配列
const NAMES = Object.keys(TETROMINOES);

// 盤面初期化
function createMatrix(w,h){
  const m = [];
  while(h--) m.push(new Array(w).fill(0));
  return m;
}

// プレイヤーオブジェクト
const player = {
  pos: {x:0,y:0},
  matrix: null,
  next: null,
  score:0,
  level:1,
};

let arena = createMatrix(COLS, ROWS);
let dropCounter = 0;
let dropInterval = 1000; // ms
let lastTime = 0;
let running = false;
let paused = false;
let requestId = null;

// --- ユーティリティ ---
function rotate(matrix){
  // matrix は 4x4 を示す1次元配列
  const size = 4;
  const out = new Array(size*size).fill(0);
  for(let y=0;y<size;y++){
    for(let x=0;x<size;x++){
      out[x*size + (size-1-y)] = matrix[y*size + x];
    }
  }
  return out;
}

function createPiece(name){
  const shapes = TETROMINOES[name];
  // shape が一つしかない場合は rotate を生成
  let variants = shapes.map(s=>s.slice());
  // generate 3 more rotations
  while(variants.length < 4){
    variants.push(rotate(variants[variants.length-1]));
  }
  return {name, variants, rot:0};
}

function collide(arena, player){
  const m = player.matrix.variants[player.matrix.rot];
  for(let y=0;y<4;y++){
    for(let x=0;x<4;x++){
      const val = m[y*4 + x];
      if(val !== 0){
        const px = x + player.pos.x;
        const py = y + player.pos.y;
        if(py < 0) continue; // off top ok
        if(!arena[py] || arena[py][px] !== 0) return true;
      }
    }
  }
  return false;
}

function merge(arena, player){
  const m = player.matrix.variants[player.matrix.rot];
  for(let y=0;y<4;y++){
    for(let x=0;x<4;x++){
      const val = m[y*4 + x];
      if(val !== 0){
        const px = x + player.pos.x;
        const py = y + player.pos.y;
        if(py >= 0 && py < ROWS && px >= 0 && px < COLS) arena[py][px] = val;
      }
    }
  }
}

function rotatePlayer(dir){
  const prev = player.matrix.rot;
  player.matrix.rot = (player.matrix.rot + (dir>0?1:3)) % 4;
  // wall kick simple: try shifts
  const kicks = [0, -1, 1, -2, 2];
  for(let i=0;i<kicks.length;i++){
    player.pos.x += kicks[i];
    if(!collide(arena, player)) return;
    player.pos.x -= kicks[i];
  }
  player.matrix.rot = prev; // restore if failed
}

function sweepRows(){
  let rowCount = 0;
  outer: for(let y=ROWS-1;y>=0;y--){
    for(let x=0;x<COLS;x++){
      if(arena[y][x] === 0) { continue outer; }
    }
    // row full
    const row = arena.splice(y,1)[0].fill(0);
    arena.unshift(new Array(COLS).fill(0));
    y++; // re-check same index
    rowCount++;
  }
  if(rowCount>0){
    // スコア計算 (classic tetris-ish)
    const points = [0,40,100,300,1200];
    player.score += (points[rowCount] || 0) * player.level;
    player.level = Math.floor(player.score / 500) + 1;
    dropInterval = Math.max(100, 1000 - (player.level-1)*80);
    updateUI();
  }
}

function resetPlayer(){
  player.matrix = player.next || createPiece(randomName());
  player.next = createPiece(randomName());
  player.pos.y = -2;
  player.pos.x = Math.floor((COLS - 4) / 2);
  if(collide(arena, player)){
    // Game over - clear arena
    arena = createMatrix(COLS, ROWS);
    player.score = 0;
    player.level = 1;
    dropInterval = 1000;
    updateUI();
  }
}

function randomName(){
  return NAMES[Math.floor(Math.random()*NAMES.length)];
}

// --- 描画 ---
function drawMatrix(ctx, matrix, offsetX, offsetY, blockSize){
  const size = 4;
  for(let y=0;y<size;y++){
    for(let x=0;x<size;x++){
      const val = matrix[y*4 + x];
      if(val !== 0){
        drawBlock(ctx, offsetX + x*blockSize, offsetY + y*blockSize, blockSize, COLORS[val]);
      }
    }
  }
}

function drawBlock(ctx,x,y,size,color){
  ctx.fillStyle = color;
  ctx.fillRect(x+1,y+1,size-2,size-2);
  // border highlight
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 1;
  ctx.strokeRect(x+1,y+1,size-2,size-2);
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // 背景グリッド
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      const val = arena[y][x];
      if(val){
        drawBlock(ctx, x*BLOCK, y*BLOCK, BLOCK, COLORS[val]);
      } else {
        // optional faint grid
        ctx.fillStyle = 'rgba(255,255,255,0.02)';
        ctx.fillRect(x*BLOCK, y*BLOCK, BLOCK-1, BLOCK-1);
      }
    }
  }
  // プレイヤーのピース
  drawMatrix(ctx, player.matrix.variants[player.matrix.rot], player.pos.x*BLOCK, player.pos.y*BLOCK, BLOCK);
}

function drawNext(){
  nextCtx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
  const box = 24; // block size for next
  const offX = (nextCanvas.width - box*4)/2;
  const offY = (nextCanvas.height - box*4)/2;
  drawMatrix(nextCtx, player.next.variants[player.next.rot], offX, offY, box);
}

// --- ゲームループ ---
function update(time = 0){
  if(!running || paused) return;
  const delta = time - lastTime;
  lastTime = time;
  dropCounter += delta;
  if(dropCounter > dropInterval){
    playerDrop();
  }
  draw();
  requestId = requestAnimationFrame(update);
}

function playerDrop(){
  player.pos.y++;
  if(collide(arena, player)){
    player.pos.y--;
    merge(arena, player);
    sweepRows();
    resetPlayer();
  }
  dropCounter = 0;
}

function playerMove(dir){
  player.pos.x += dir;
  if(collide(arena, player)) player.pos.x -= dir;
}

function playerHardDrop(){
  while(!collide(arena, player)) player.pos.y++;
  player.pos.y--;
  merge(arena, player);
  sweepRows();
  resetPlayer();
  dropCounter = 0;
}

// --- UI ---
const scoreEl = document.getElementById('score');
const levelEl = document.getElementById('level');
function updateUI(){
  scoreEl.textContent = player.score;
  levelEl.textContent = player.level;
  drawNext();
}

// --- 入力 ---
document.addEventListener('keydown', e=>{
  if(!running) return;
  if(e.key === 'ArrowLeft') { playerMove(-1); }
  else if(e.key === 'ArrowRight') { playerMove(1); }
  else if(e.key === 'ArrowDown') { playerDrop(); }
  else if(e.key === 'ArrowUp') { rotatePlayer(1); }
  else if(e.code === 'Space') { e.preventDefault(); playerHardDrop(); }
  else if(e.key === 'p' || e.key === 'P') { togglePause(); }
  draw();
});

// ボタン
document.getElementById('start').addEventListener('click', ()=>{
  startGame();
});

document.getElementById('pause').addEventListener('click', ()=>{
  togglePause();
});

function togglePause(){
  if(!running) return;
  paused = !paused;
  if(paused){
    cancelAnimationFrame(requestId);
    document.getElementById('pause').textContent = '再開';
  } else {
    lastTime = performance.now();
    requestId = requestAnimationFrame(update);
    document.getElementById('pause').textContent = '一時停止';
  }
}

function startGame(){
  // reset everything
  arena = createMatrix(COLS, ROWS);
  player.score = 0;
  player.level = 1;
  player.matrix = createPiece(randomName());
  player.next = createPiece(randomName());
  player.pos = {x: Math.floor((COLS-4)/2), y:-2};
  dropInterval = 1000;
  running = true;
  paused = false;
  document.getElementById('pause').textContent = '一時停止';
  updateUI();
  lastTime = performance.now();
  cancelAnimationFrame(requestId);
  requestId = requestAnimationFrame(update);
}

// --- 初期表示 ---
// プレースホルダーの next を作る
player.next = createPiece(randomName());
player.matrix = createPiece(randomName());
player.pos = {x: Math.floor((COLS-4)/2), y:-2};
updateUI();

</script>
</body>
</html>
